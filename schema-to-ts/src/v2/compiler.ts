import type {
  CompilerContext,
  SchemaPath,
  TopLevelPluginContext,
} from './types.ts';
import { Project, SourceFile } from 'ts-morph';
import { docStringLines, idToTypeName, refToSchemaName } from './helpers.ts';

import type { CompilerOptions } from '../types.ts';
import { TOP_LEVEL_PLUGINS } from './plugins/index.ts';
import { format } from '../formatter.ts';
import fs from 'node:fs';
import { logger } from '../utils.ts';
import renderType from './renderType.ts';

/**
 * The top-level interface for compiling the zapier-platform-schema
 * document into a TypeScript file.
 */
export async function compileV2(options: CompilerOptions) {
  const { version, schemas } = JSON.parse(
    fs.readFileSync(options.schemaJson!, 'utf8'),
  );
  logger.info({ version }, 'Loaded %d schemas', Object.keys(schemas).length);

  // File is the ts-morph object used to construct the output file.
  const project = new Project();
  const file = project.createSourceFile('dummy-value.ts');

  addPreamble(file, options);
  addImports(file);

  const ctx: CompilerContext = {
    file,
    schemas,
    schemasToRender: ['/AppSchema'], // "Entrypoint" schema. More will get added.
    renderedSchemas: new Set(),
  };

  // Keep adding top-level types until we've added all of them. This
  // lets us ignore things in the schema that aren't used by AppSchema.
  while (ctx.schemasToRender.length > 0) {
    const schemaName = ctx.schemasToRender.shift()!;
    addTopLevelType(ctx, schemaName);
  }

  // Sanity check that we've rendered all of the schemas that should be.
  const allSchemas = Object.keys(schemas).map(
    (k): SchemaPath => `/${k}` as SchemaPath,
  );
  const unrenderedSchemas = allSchemas.filter(
    (s) => !ctx.renderedSchemas.has(s),
  );
  if (unrenderedSchemas.length > 0) {
    logger.warn(
      { unrenderedSchemas },
      '%d schemas unreachable from AppSchema. These have not been added to the output file.',
      unrenderedSchemas.length,
    );
  }

  // Done! Format it with prettier and write it to the output file.
  const rawTypeScript = file.getFullText();
  const formatted = await format(rawTypeScript);
  fs.writeFileSync(options.output!, formatted);
  logger.info({ output: options.output }, 'Wrote generated TypeScript to file');
}

function addTopLevelType(ctx: CompilerContext, schemaPath: SchemaPath) {
  const schema = ctx.schemas[refToSchemaName(schemaPath)];
  if (!schema) {
    logger.fatal({ schemaPath }, 'Top-level schema not found');
    throw new Error(`Top-level schema not found: ${schemaPath}`);
  }

  // Skip if we've already added this type.
  if (ctx.renderedSchemas.has(schemaPath)) {
    logger.trace('Skipping already rendered top-level type %s', schemaPath);
    return;
  }
  ctx.renderedSchemas.add(schemaPath);

  // Work through the plugins in order of priority, running them if they
  // match the schema. Otherwise, we'll fall back to the default type.
  logger.trace('Beginning plugin search for top-level type %s', schemaPath);

  const pluginContext: TopLevelPluginContext = {
    ...ctx,
    schema,
    schemaPath,
    schemaTypeName: idToTypeName(schemaPath),
  };

  for (const plugin of TOP_LEVEL_PLUGINS) {
    if (plugin.test(pluginContext)) {
      logger.info('Using %s to render %s', plugin.constructor.name, schemaPath);
      plugin.render(pluginContext);
      logger.debug('Rendered %s with %s', schemaPath, plugin.constructor.name);
      return;
    }
  }

  logger.info('Using default type renderer for %s', schemaPath);
  const { rawType, referencedTypes } = renderType(schema);
  if (referencedTypes) {
    ctx.schemasToRender.push(...referencedTypes);
  }
  ctx.file.addTypeAlias({
    name: idToTypeName(schemaPath),
    docs: docStringLines(schema.description),
    isExported: true,
    type: rawType,
    leadingTrivia: '\n',
  });
}

function addPreamble(file: SourceFile, options: CompilerOptions) {
  const preamble = `/**
* This file was automatically generated by Zapier's schema-to-ts tool.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema
* files, and/or the schema-to-ts tool and run its CLI to regenerate
* these typings.
* 
* zapier-platform-schema version: ${options.platformVersion}
*  schema-to-ts compiler version: ${options.compilerVersion}
*/`;
  file.insertText(0, (writer) => writer.writeLine(preamble));
}

function addImports(file: SourceFile) {
  file.addImportDeclarations([
    {
      namedImports: [
        'AfterResponseMiddleware',
        'BeforeRequestMiddleware',
        'PerformFunction',
      ],
      moduleSpecifier: './custom',
      leadingTrivia: '\n',
      isTypeOnly: true,
    },
    {
      moduleSpecifier: './functions',
      isTypeOnly: true,
      namedImports: [
        'PollingTriggerPerform',
        'WebhookTriggerPerform',
        'WebhookTriggerPerformList',
        'WebhookTriggerPerformSubscribe',
        'WebhookTriggerPerformUnsubscribe',
        'HookToPollTriggerPerformList',
        'HookToPollTriggerPerformSubscribe',
        'HookToPollTriggerPerformUnsubscribe',
        'CreatePerform',
        'CreatePerformResume',
        'CreatePerformGet',
        'SearchPerform',
        'SearchPerformGet',
        'SearchPerformResume',
        'OAuth2AuthorizeUrl',
        'OAuth2GetAccessToken',
        'OAuth2RefreshAccessToken',
      ],
    },
  ]);
}
