/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run `yarn gen-defs` in the `core` repo to regenerate this file.
 */

/**
 * Represents a simplified semver string, from `0.0.0` to `999.999.999`.
 */
export type VersionSchema = string;
/**
 * List of before or after middlewares. Can be an array of functions or a single function
 */
export type MiddlewaresSchema = FunctionSchema[] | FunctionSchema;
/**
 * Internal pointer to a function from the original source or the source code itself. Encodes arity and if `arguments` is used in the body. Note - just write normal functions and the system will encode the pointers for you. Or, provide {source: "return 1 + 2"} and the system will wrap in a function for you.
 */
export type FunctionSchema = string | FunctionRequireSchema | FunctionSourceSchema;
/**
 * Reference a resource by key and the data it returns. In the format of: `{resource_key}.{foreign_key}(.{human_label_key})`.
 */
export type RefResourceSchema = string;
/**
 * A static dropdown of options. Which you use depends on your order and label requirements:
 *
 * Need a Label? | Does Order Matter? | Type to Use
 * ---|---|---
 * Yes | No | Object of value -> label
 * No | Yes | Array of Strings
 * Yes | Yes | Array of [FieldChoiceWithLabel](#fieldchoicewithlabelschema)
 */
export type FieldChoicesSchema =
  | {
      [k: string]: unknown;
    }
  | [string | FieldChoiceWithLabelSchema, ...(string | FieldChoiceWithLabelSchema)[]];
/**
 * An array or collection of fields.
 */
export type FieldsSchema = FieldSchema[];
/**
 * A unique identifier for this item.
 */
export type KeySchema = string;
/**
 * Like [/FieldsSchema](#fieldsschema) but you can provide functions to create dynamic or custom fields.
 */
export type DynamicFieldsSchema = FieldOrFunctionSchema;
/**
 * Represents an array of fields or functions.
 */
export type FieldOrFunctionSchema = (FieldSchema | FunctionSchema)[];

/**
 * Represents a full app.
 */
export interface ZapierIntegration {
  /**
   * A version identifier for your code.
   */
  version: VersionSchema;
  /**
   * A version identifier for the Zapier execution environment.
   */
  platformVersion: VersionSchema;
  /**
   * EXPERIMENTAL: Before the perform method is called on your app, you can modify the execution context.
   */
  beforeApp?: MiddlewaresSchema;
  /**
   * EXPERIMENTAL: After the perform method is called on your app, you can modify the response.
   */
  afterApp?: MiddlewaresSchema;
  /**
   * Choose what scheme your API uses for authentication.
   */
  authentication?: AuthenticationSchema;
  /**
   * Define a request mixin, great for setting custom headers, content-types, etc.
   */
  requestTemplate?: RequestSchema;
  /**
   * Before an HTTP request is sent via our `z.request()` client, you can modify it.
   */
  beforeRequest?: MiddlewaresSchema;
  /**
   * After an HTTP response is recieved via our `z.request()` client, you can modify it.
   */
  afterResponse?: MiddlewaresSchema;
  /**
   * An optional bank of named functions that you can use in `z.hydrate('someName')` to lazily load data.
   */
  hydrators?: HydratorsSchema;
  /**
   * All the resources for your app. Zapier will take these and generate the relevent triggers/searches/creates automatically.
   */
  resources?: ResourcesSchema;
  /**
   * All the triggers for your app. You can add your own here, or Zapier will automatically register any from the list/hook methods on your resources.
   */
  triggers?: TriggersSchema;
  /**
   * All the searches for your app. You can add your own here, or Zapier will automatically register any from the search method on your resources.
   */
  searches?: SearchesSchema;
  /**
   * All the creates for your app. You can add your own here, or Zapier will automatically register any from the create method on your resources.
   */
  creates?: CreatesSchema;
  /**
   * All the search-or-create combos for your app. You can create your own here, or Zapier will automatically register any from resources that define a search, a create, and a get (or define a searchOrCreate directly). Register non-resource search-or-creates here as well.
   */
  searchOrCreates?: SearchOrCreatesSchema;
  /**
   * Top-level app options
   */
  flags?: AppFlagsSchema;
  /**
   * **INTERNAL USE ONLY**. Zapier uses this to hold properties from a legacy Web Builder app.
   */
  legacy?: {
    [k: string]: unknown;
  };
}
/**
 * A path to a file that might have content like `module.exports = (z, bundle) => [{id: 123}];`.
 */
export interface FunctionRequireSchema {
  require: string;
}
/**
 * Source code like `{source: "return 1 + 2"}` which the system will wrap in a function for you.
 */
export interface FunctionSourceSchema {
  /**
   * JavaScript code for the function body. This must end with a `return` statement.
   */
  source: string;
  /**
   * Function signature. Defaults to `['z', 'bundle']` if not specified.
   */
  args?: string[];
}
/**
 * Represents authentication schemes.
 */
export interface AuthenticationSchema {
  /**
   * Choose which scheme you want to use.
   */
  type: "basic" | "custom" | "digest" | "oauth1" | "oauth2" | "session";
  /**
   * A function or request that confirms the authentication is working.
   */
  test: RequestSchema | FunctionSchema;
  /**
   * Fields you can request from the user before they connect your app to Zapier.
   */
  fields?: FieldsSchema;
  /**
   * A string with variables, function, or request that returns the connection label for the authenticated user.
   */
  connectionLabel?: RequestSchema | FunctionSchema | string;
  basicConfig?: AuthenticationBasicConfigSchema;
  customConfig?: AuthenticationCustomConfigSchema;
  digestConfig?: AuthenticationDigestConfigSchema;
  oauth1Config?: AuthenticationOAuth1ConfigSchema;
  oauth2Config?: AuthenticationOAuth2ConfigSchema;
  sessionConfig?: AuthenticationSessionConfigSchema;
}
/**
 * A representation of a HTTP request - you can use the `{{syntax}}` to inject authentication, field or global variables.
 */
export interface RequestSchema {
  /**
   * The HTTP method for the request.
   */
  method?: "GET" | "PUT" | "POST" | "PATCH" | "DELETE" | "HEAD";
  /**
   * A URL for the request (we will parse the querystring and merge with params). Keys and values will not be re-encoded.
   */
  url?: string;
  /**
   * Can be nothing, a raw string or JSON (object or array).
   */
  body?:
    | null
    | string
    | {
        [k: string]: unknown;
      }
    | unknown[];
  /**
   * A mapping of the querystring - will get merged with any query params in the URL. Keys and values will be encoded.
   */
  params?: FlatObjectSchema;
  /**
   * The HTTP headers for the request.
   */
  headers?: FlatObjectSchema;
  /**
   * An object holding the auth parameters for OAuth1 request signing, like `{oauth_token: 'abcd', oauth_token_secret: '1234'}`. Or an array reserved (i.e. not implemented yet) to hold the username and password for Basic Auth. Like `['AzureDiamond', 'hunter2']`.
   */
  auth?: string[] | FlatObjectSchema;
  /**
   * Should missing values be sent? (empty strings, `null`, and `undefined` only â€” `[]`, `{}`, and `false` will still be sent). Allowed fields are `params` and `body`. The default is `false`, ex: ```removeMissingValuesFrom: { params: false, body: false }```
   */
  removeMissingValuesFrom?: {
    /**
     * Refers to data sent via a requests query params (`req.params`)
     */
    params?: boolean;
    /**
     * Refers to tokens sent via a requsts body (`req.body`)
     */
    body?: boolean;
  };
  /**
   * A function to customize how to serialize a value for curlies `{{var}}` in the request object. By default, when this is unspecified, the request client only replaces curlies where variables are strings, and would throw an error for non-strings. The function should accepts a single argument as the value to be serialized and return the string representation of the argument.
   */
  serializeValueForCurlies?: FunctionSchema;
  /**
   * If `true`, don't throw an exception for response 400 <= status < 600 automatically before resolving with the response. Defaults to `false`.
   */
  skipThrowForStatus?: boolean;
}
/**
 * An object whose values can only be primitives
 */
export interface FlatObjectSchema {
  /**
   * Any key may exist in this flat object as long as its values are simple.
   *
   * This interface was referenced by `FlatObjectSchema`'s JSON-Schema definition
   * via the `patternProperty` "[^\s]+".
   */
  [k: string]: null | string | number | boolean;
}
/**
 * Defines a field an app either needs as input, or gives as output. In addition to the requirements below, the following keys are mutually exclusive:
 *
 * * `children` & `list`
 * * `children` & `dict`
 * * `children` & `type`
 * * `children` & `placeholder`
 * * `children` & `helpText`
 * * `children` & `default`
 * * `dict` & `list`
 * * `dynamic` & `dict`
 * * `dynamic` & `choices`
 */
export interface FieldSchema {
  /**
   * A unique machine readable key for this value (IE: "fname").
   */
  key: string;
  /**
   * A human readable label for this value (IE: "First Name").
   */
  label?: string;
  /**
   * A human readable description of this value (IE: "The first part of a full name."). You can use Markdown.
   */
  helpText?: string;
  /**
   * The type of this value.
   */
  type?: "string" | "text" | "integer" | "number" | "boolean" | "datetime" | "file" | "password" | "copy";
  /**
   * If this value is required or not.
   */
  required?: boolean;
  /**
   * An example value that is not saved.
   */
  placeholder?: string;
  /**
   * A default value that is saved the first time a Zap is created.
   */
  default?: string;
  /**
   * A reference to a trigger that will power a dynamic dropdown.
   */
  dynamic?: RefResourceSchema;
  /**
   * A reference to a search that will guide the user to add a search step to populate this field when creating a Zap.
   */
  search?: RefResourceSchema;
  /**
   * An object of machine keys and human values to populate a static dropdown.
   */
  choices?: FieldChoicesSchema;
  /**
   * Acts differently when used in inputFields vs. when used in outputFields. In inputFields: Can a user provide multiples of this field? In outputFields: Does this field return an array of items of type `type`?
   */
  list?: boolean;
  /**
   * An array of child fields that define the structure of a sub-object for this field. Usually used for line items.
   */
  children?: [FieldSchema, ...FieldSchema[]];
  /**
   * Is this field a key/value input?
   */
  dict?: boolean;
  /**
   * Is this field automatically populated (and hidden from the user)?
   */
  computed?: boolean;
  /**
   * Does the value of this field affect the definitions of other fields in the set?
   */
  altersDynamicFields?: boolean;
  /**
   * Useful when you expect the input to be part of a longer string. Put "{{input}}" in place of the user's input (IE: "https://{{input}}.yourdomain.com").
   */
  inputFormat?: string;
}
/**
 * An object describing a labeled choice in a static dropdown. Useful if the value a user picks isn't exactly what the zap uses. For instance, when they click on a nickname, but the zap uses the user's full name ([image](https://cdn.zapier.com/storage/photos/8ed01ac5df3a511ce93ed2dc43c7fbbc.png)).
 */
export interface FieldChoiceWithLabelSchema {
  /**
   * The actual value that is sent into the Zap. Should match sample exactly.
   */
  value: string;
  /**
   * Displayed as light grey text in the editor. It's important that the value match the sample. Otherwise, the actual value won't match what the user picked, which is confusing.
   */
  sample: string;
  /**
   * A human readable label for this value.
   */
  label: string;
  [k: string]: unknown;
}
/**
 * Config for Basic Authentication. No extra properties are required to setup Basic Auth, so you can leave this empty if your app uses Basic Auth.
 */
export interface AuthenticationBasicConfigSchema {}
/**
 * Config for custom authentication (like API keys). No extra properties are required to setup this auth type, so you can leave this empty if your app uses a custom auth method.
 */
export interface AuthenticationCustomConfigSchema {}
/**
 * Config for Digest Authentication. No extra properties are required to setup Digest Auth, so you can leave this empty if your app uses Digets Auth.
 */
export interface AuthenticationDigestConfigSchema {}
/**
 * Config for OAuth1 authentication.
 */
export interface AuthenticationOAuth1ConfigSchema {
  /**
   * Define where Zapier will acquire a request token which is used for the rest of the three legged authentication process.
   */
  getRequestToken: RequestSchema | FunctionSchema;
  /**
   * Define where Zapier will redirect the user to authorize our app. Typically, you should append an `oauth_token` querystring parameter to the request.
   */
  authorizeUrl: RedirectRequestSchema | FunctionSchema;
  /**
   * Define how Zapier fetches an access token from the API
   */
  getAccessToken: RequestSchema | FunctionSchema;
}
/**
 * A representation of a HTTP redirect - you can use the `{{syntax}}` to inject authentication, field or global variables.
 */
export interface RedirectRequestSchema {
  /**
   * The HTTP method for the request.
   */
  method?: "GET";
  /**
   * A URL for the request (we will parse the querystring and merge with params). Keys and values will not be re-encoded.
   */
  url?: string;
  /**
   * A mapping of the querystring - will get merged with any query params in the URL. Keys and values will be encoded.
   */
  params?: FlatObjectSchema;
}
/**
 * Config for OAuth2 authentication.
 */
export interface AuthenticationOAuth2ConfigSchema {
  /**
   * Define where Zapier will redirect the user to authorize our app. Note: we append the redirect URL and state parameters to return value of this function.
   */
  authorizeUrl: RedirectRequestSchema | FunctionSchema;
  /**
   * Define how Zapier fetches an access token from the API
   */
  getAccessToken: RequestSchema | FunctionSchema;
  /**
   * Define how Zapier will refresh the access token from the API
   */
  refreshAccessToken?: RequestSchema | FunctionSchema;
  /**
   * What scope should Zapier request?
   */
  scope?: string;
  /**
   * Should Zapier invoke `refreshAccessToken` when we receive an error for a 401 response?
   */
  autoRefresh?: boolean;
}
/**
 * Config for session authentication.
 */
export interface AuthenticationSessionConfigSchema {
  /**
   * Define how Zapier fetches the additional authData needed to make API calls.
   */
  perform: RequestSchema | FunctionSchema;
}
/**
 * A bank of named functions that you can use in `z.hydrate('someName')` to lazily load data.
 */
export interface HydratorsSchema {
  /**
   * Any unique key can be used in `z.hydrate('uniqueKeyHere')`.
   *
   * This interface was referenced by `HydratorsSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9]*$".
   */
  [k: string]: FunctionSchema;
}
/**
 * All the resources that underlie common CRUD methods powering automatically handled triggers, creates, and searches for your app. Zapier will break these apart for you.
 */
export interface ResourcesSchema {
  /**
   * Any unique key can be used and its values will be validated against the ResourceSchema.
   *
   * This interface was referenced by `ResourcesSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: ResourceSchema;
}
/**
 * Represents a resource, which will in turn power triggers, searches, or creates.
 */
export interface ResourceSchema {
  /**
   * A key to uniquely identify this resource.
   */
  key: KeySchema;
  /**
   * A noun for this resource that completes the sentence "create a new XXX".
   */
  noun: string;
  /**
   * How will we get a single object given a unique identifier/id?
   */
  get?: ResourceMethodGetSchema;
  /**
   * How will we get notified of new objects? Will be turned into a trigger automatically.
   */
  hook?: ResourceMethodHookSchema;
  /**
   * How will we get a list of new objects? Will be turned into a trigger automatically.
   */
  list?: ResourceMethodListSchema;
  /**
   * How will we find a specific object given filters or search terms? Will be turned into a search automatically.
   */
  search?: ResourceMethodSearchSchema;
  /**
   * How will we find create a specific object given inputs? Will be turned into a create automatically.
   */
  create?: ResourceMethodCreateSchema;
  /**
   * What fields of data will this return?
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like?
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get a single object given a unique identifier/id?
 */
export interface ResourceMethodGetSchema {
  /**
   * Define how this get method will be exposed in the UI.
   */
  display: BasicDisplaySchema;
  /**
   * Define how this get method will work.
   */
  operation: BasicOperationSchema;
}
/**
 * Represents user information for a trigger, search, or create.
 */
export interface BasicDisplaySchema {
  /**
   * A short label like "New Record" or "Create Record in Project". Optional if `hidden` is true.
   */
  label?: string;
  /**
   * A description of what this trigger, search, or create does. Optional if `hidden` is true.
   */
  description?: string;
  /**
   * A short blurb that can explain how to get this working. EG: how and where to copy-paste a static hook URL into your application. Only evaluated for static webhooks.
   */
  directions?: string;
  /**
   * Affects how prominently this operation is displayed in the UI. Only mark a few of the most popular operations important.
   */
  important?: boolean;
  /**
   * Should this operation be unselectable by users?
   */
  hidden?: boolean;
}
/**
 * Represents the fundamental mechanics of triggers, searches, or creates.
 */
export interface BasicOperationSchema {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: KeySchema;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestSchema | FunctionSchema;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFieldsSchema;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get notified of new objects? Will be turned into a trigger automatically.
 */
export interface ResourceMethodHookSchema {
  /**
   * Define how this hook/trigger method will be exposed in the UI.
   */
  display: BasicDisplaySchema;
  /**
   * Define how this hook/trigger method will work.
   */
  operation: BasicHookOperationSchema;
}
/**
 * Represents the inbound mechanics of hooks with optional subscribe/unsubscribe. Defers to list for fields.
 */
export interface BasicHookOperationSchema {
  /**
   * Must be explicitly set to `"hook"` unless this hook is defined as part of a resource, in which case it's optional.
   */
  type?: "hook";
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: KeySchema;
  /**
   * A function that processes the inbound webhook request.
   */
  perform: FunctionSchema;
  /**
   * Can get "live" data on demand instead of waiting for a hook. If you find yourself reaching for this - consider resources and their built-in hook/list methods. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performList?: RequestSchema | FunctionSchema;
  /**
   * Takes a URL and any necessary data from the user and subscribes. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performSubscribe?: RequestSchema | FunctionSchema;
  /**
   * Takes a URL and data from a previous subscribe call and unsubscribes. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performUnsubscribe?: RequestSchema | FunctionSchema;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFieldsSchema;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get a list of new objects? Will be turned into a trigger automatically.
 */
export interface ResourceMethodListSchema {
  /**
   * Define how this list/trigger method will be exposed in the UI.
   */
  display: BasicDisplaySchema;
  /**
   * Define how this list/trigger method will work.
   */
  operation: BasicPollingOperationSchema;
}
/**
 * Represents the fundamental mechanics of a trigger.
 */
export interface BasicPollingOperationSchema {
  /**
   * Clarify how this operation works (polling == pull or hook == push).
   */
  type?: "polling";
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: KeySchema;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestSchema | FunctionSchema;
  /**
   * Does this endpoint support a page offset?
   */
  canPaginate?: boolean;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFieldsSchema;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we find a specific object given filters or search terms? Will be turned into a search automatically.
 */
export interface ResourceMethodSearchSchema {
  /**
   * Define how this search method will be exposed in the UI.
   */
  display: BasicDisplaySchema;
  /**
   * Define how this search method will work.
   */
  operation: BasicActionOperationSchema;
}
/**
 * Represents the fundamental mechanics of a search/create.
 */
export interface BasicActionOperationSchema {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: KeySchema;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestSchema | FunctionSchema;
  /**
   * A function that parses data from a perform + callback to resume this action. For use with callback semantics
   */
  performResume?: FunctionSchema;
  /**
   * How will Zapier get a single record? If you find yourself reaching for this - consider resources and their built-in get methods.
   */
  performGet?: RequestSchema | FunctionSchema;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFieldsSchema;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we find create a specific object given inputs? Will be turned into a create automatically.
 */
export interface ResourceMethodCreateSchema {
  /**
   * Define how this create method will be exposed in the UI.
   */
  display: BasicDisplaySchema;
  /**
   * Define how this create method will work.
   */
  operation: BasicActionOperationSchema;
}
/**
 * Enumerates the triggers your app has available for users.
 */
export interface TriggersSchema {
  /**
   * Any unique key can be used and its values will be validated against the TriggerSchema.
   *
   * This interface was referenced by `TriggersSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: TriggerSchema;
}
/**
 * How will Zapier get notified of new objects?
 */
export interface TriggerSchema {
  /**
   * A key to uniquely identify this trigger.
   */
  key: KeySchema;
  /**
   * A noun for this trigger that completes the sentence "triggers on a new XXX".
   */
  noun: string;
  /**
   * Configures the UI for this trigger.
   */
  display: BasicDisplaySchema;
  /**
   * Powers the functionality for this trigger.
   */
  operation: BasicPollingOperationSchema | BasicHookOperationSchema;
}
/**
 * Enumerates the searches your app has available for users.
 */
export interface SearchesSchema {
  /**
   * Any unique key can be used and its values will be validated against the SearchSchema.
   *
   * This interface was referenced by `SearchesSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: SearchSchema;
}
/**
 * How will Zapier search for existing objects?
 */
export interface SearchSchema {
  /**
   * A key to uniquely identify this search.
   */
  key: KeySchema;
  /**
   * A noun for this search that completes the sentence "finds a specific XXX".
   */
  noun: string;
  /**
   * Configures the UI for this search.
   */
  display: BasicDisplaySchema;
  /**
   * Powers the functionality for this search.
   */
  operation: BasicActionOperationSchema;
}
/**
 * Enumerates the creates your app has available for users.
 */
export interface CreatesSchema {
  /**
   * Any unique key can be used and its values will be validated against the CreateSchema.
   *
   * This interface was referenced by `CreatesSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: CreateSchema;
}
/**
 * How will Zapier create a new object?
 */
export interface CreateSchema {
  /**
   * A key to uniquely identify this create.
   */
  key: KeySchema;
  /**
   * A noun for this create that completes the sentence "creates a new XXX".
   */
  noun: string;
  /**
   * Configures the UI for this create.
   */
  display: BasicDisplaySchema;
  /**
   * Powers the functionality for this create.
   */
  operation: BasicCreateActionOperationSchema;
}
/**
 * Represents the fundamental mechanics of a create.
 */
export interface BasicCreateActionOperationSchema {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: KeySchema;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestSchema | FunctionSchema;
  /**
   * A function that parses data from a perform + callback to resume this action. For use with callback semantics
   */
  performResume?: FunctionSchema;
  /**
   * How will Zapier get a single record? If you find yourself reaching for this - consider resources and their built-in get methods.
   */
  performGet?: RequestSchema | FunctionSchema;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFieldsSchema;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFieldsSchema;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
  /**
   * Should this action be performed one at a time (avoid concurrency)?
   */
  shouldLock?: boolean;
}
/**
 * Enumerates the search-or-creates your app has available for users.
 */
export interface SearchOrCreatesSchema {
  /**
   * Any unique key can be used and its values will be validated against the SearchOrCreateSchema.
   *
   * This interface was referenced by `SearchOrCreatesSchema`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: SearchOrCreateSchema;
}
/**
 * Pair an existing search and a create to enable "Find or Create" functionality in your app
 */
export interface SearchOrCreateSchema {
  /**
   * A key to uniquely identify this search-or-create. Must match the search key.
   */
  key: KeySchema;
  /**
   * Configures the UI for this search-or-create.
   */
  display: BasicDisplaySchema;
  /**
   * The key of the search that powers this search-or-create
   */
  search: KeySchema;
  /**
   * The key of the create that powers this search-or-create
   */
  create: KeySchema;
}
/**
 * Codifies high-level options for your app.
 */
export interface AppFlagsSchema {
  /**
   * By default, Zapier patches the core `http` module so that all requests (including those from 3rd-party SDKs) can be logged. Set this to true if you're seeing issues using an SDK (such as AWS).
   */
  skipHttpPatch?: boolean;
}
