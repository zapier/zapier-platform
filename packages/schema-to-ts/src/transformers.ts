import { CompilerOptions, NamedAst, NodeMap } from './types.js';
import { insertAtFront, logger } from './utils.js';

/**
 * A transformer that takes a node and can return a new node with
 * changes made.
 */
type NodeTransformer = (node: NamedAst, options: CompilerOptions) => NamedAst;

/**
 * A transformer that takes a whole map of nodes and can return a new
 * map with changes made. Allows for more complex transformations that
 * add or remove top-level schema nodes.
 */
type MapTransformer = (nodeMap: NodeMap, options: CompilerOptions) => NodeMap;

/**
 * Converts a NodeTransformer into a MapTransformer that applies the
 * node transformer to every node in the map.
 */
const makeMapTransformer =
  (transformer: NodeTransformer): MapTransformer =>
  (nodeMap, options) =>
    new Map(
      Array.from(nodeMap.entries()).map(([key, node]) => [
        key,
        transformer(node, options),
      ]),
    );

const mapTransformers: Map<string, MapTransformer> = new Map();

mapTransformers.set(
  'add-github-links',
  makeMapTransformer((node) => {
    const comment = node.comment ?? '';
    // TODO: This will occasionally produce a dead link for the schemas
    // that are hidden from the public docs.
    const url = `https://github.com/zapier/zapier-platform/blob/main/packages/schema/docs/build/schema.md#${node.standaloneName}`;
    return {
      ...node,
      comment: `${comment}\n\n[Docs: ${node.standaloneName}](${url})`,
    };
  }),
);

mapTransformers.set(
  'patch-function-types',
  (nodeMap, options: CompilerOptions) => {
    /**
     * Injects a reference to the PerformFunction type into the
     * FunctionSchema, because in JSON Schema the type is a union of just
     * strings and serialised function payloads.
     */
    const injectFunctionReference = makeMapTransformer((node) => {
      // Search for the "FunctionSchema" JsonSchema, and patch in a
      // references to the (also injected) `PerformFunction` type.
      if (node.standaloneName === 'FunctionSchema' && node.type === 'UNION') {
        const performFuncReference: NamedAst = {
          standaloneName: 'PerformFunction',
          type: 'CUSTOM_TYPE',
          params: `func-ref:perform`,
        };
        return {
          ...node,
          // TODO: Perhaps don't bother with the extra source string
          // formats, and use the `PerformFunction` type directly
          // throughout the interfaces.
          params: [performFuncReference, ...node.params],
        };
      }
      // Leave every other node unchanged.
      return node;
    });
    const withFunctionReference = injectFunctionReference(nodeMap, options);

    // Add the `ZObject` and `Bundle` imports to the top of the file.
    const withFuncAndImport = insertAtFront(
      withFunctionReference,
      'import ZPC object',
      snippetNode({
        content: `import type { Bundle, ZObject } from "${options.platformCoreCustomImport}";`,
        name: 'ZPC import',
      }),
    );

    // Add a type definition for the `PerformFunction`, which is an
    // async function that takes a `ZObject` and a `Bundle` from the
    // custom zapier-platform-core types. Added to the bottom.
    withFuncAndImport.set(
      'PerformFunction',
      snippetNode({
        content: `export type PerformFunction<BI=Record<string, any>, R=any> = (z: ZObject, bundle: Bundle<BI>) => Promise<R>;`,
        name: 'PerformFunction',
        comment:
          'A function that performs the action.\n\n@template BI The shape of data in the `bundle.inputData` object.\n@template R The return type of the function.',
      }),
    );
    return withFuncAndImport;
  },
);

mapTransformers.set('inject-preamble', (nodeMap, options) => {
  const header = `/**
 * This file was automatically generated by Zapier's schema-to-ts tool.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema
 * files, and/or the schema-to-ts tool and run its CLI to regenerate
 * these typings.
 * 
 * zapier-platform-schema version: ${options.platformVersion}
 *  schema-to-ts compiler version: ${options.compilerVersion}
 */`;

  const docNode = snippetNode({ content: header, name: 'File Header' });
  logger.debug('Injecting preamble snippet as first node in the file.');
  return insertAtFront(nodeMap, '_header', docNode);
});

export const applyAllTransformations = (
  nodeMap: NodeMap,
  options: CompilerOptions,
): NodeMap => {
  if (options.skipPatchFunctions) {
    logger.warn(
      { skipPatchFunctions: options.skipPatchFunctions },
      'Skipping patch-functions transformer because of --skip-patch-functions ',
    );
    mapTransformers.delete('patch-function-types');
  }

  logger.info(
    {
      numTransformations: mapTransformers.size,
      transformations: Array.from(mapTransformers.keys()),
    },
    '%d transformations registered to be applied',
    mapTransformers.size,
  );
  return Array.from(mapTransformers.entries()).reduce(
    (nm, [name, transformer]): NodeMap => {
      logger.info(`Applying transformer: ${name}`);
      return transformer(nm, options);
    },
    nodeMap,
  );
};

/**
 * Make a node with a CUSTOM_TYPE and a special param prefix that the
 * code generation step will know to extract and insert as a snippet of
 * content directly into the final TypeScript file.
 */
const snippetNode = ({
  content,
  name,
  comment,
}: {
  content: string;
  name?: string;
  comment?: string;
}): NamedAst => ({
  type: 'CUSTOM_TYPE',
  standaloneName: `«Snippet: ${name ?? '(anonymous)'}»`,
  comment,
  params: `insert-snippet|||${content}`,
});
