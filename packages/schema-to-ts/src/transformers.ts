import { NamedAst, NodeMap } from "./types.js";

import { logger } from "./utils.js";

/**
 * A transformer that takes a node and can return a new node with
 * changes made.
 */
type NodeTransformer = (node: NamedAst) => NamedAst;

/**
 * A transformer that takes a whole map of nodes and can return a new
 * map with changes made. Allows for more complex transformations that
 * add or remove top-level schema nodes.
 */
type MapTransformer = (schema: NodeMap) => NodeMap;

/**
 * Converts a NodeTransformer into a MapTransformer that applies the
 * node transformer to every node in the map.
 */
const makeMapTransformer =
  (transformer: NodeTransformer): MapTransformer =>
  (map) =>
    new Map(
      Array.from(map.entries()).map(([key, node]) => [key, transformer(node)]),
    );

const mapTransformers: Map<string, MapTransformer> = new Map();

mapTransformers.set(
  "Apply @link tags",
  makeMapTransformer((node) => {
    const comment = node.comment ?? "";
    const url = `https://github.com/zapier/zapier-platform/blob/main/packages/schema/docs/build/schema.md#${node.standaloneName}`;
    return {
      ...node,
      comment: `${comment}\n\n[Docs: ${node.standaloneName}](${url})`,
    };
  }),
);

mapTransformers.set("Inject real function types", (nodeMap) => {
  /**
   * Injects a reference to the PerformFunction type into the
   * FunctionSchema, as in JSONSchema the type is a union of just
   * strings and serialised function payloads.
   */
  const injectFunctionReference = makeMapTransformer((node) => {
    if (node.standaloneName === "FunctionSchema" && node.type === "UNION") {
      const performFuncReference: NamedAst = {
        standaloneName: "PerformFunction",
        type: "CUSTOM_TYPE",
        params: `func-ref:perform`,
      };
      return {
        ...node,
        params: [performFuncReference, ...node.params],
      };
    }
    return node;
  });
  const withFunctionReference = injectFunctionReference(nodeMap);
  withFunctionReference.set("import ZPC object", {
    type: "CUSTOM_TYPE",
    standaloneName: "_",
    params: `insert-snippet|||import type { Bundle, ZObject } from "zapier-platform-core";`,
  });
  withFunctionReference.set("PerformFunction", {
    type: "CUSTOM_TYPE",
    standaloneName: "PerformFunction",
    comment:
      "A function that performs the action.\n\n@template BI The shape of data in the `bundle.inputData` object.\n@template R The return type of the function.",
    params:
      "insert-snippet|||export type PerformFunction<BI=Record<string, any>, R=any> = (z: ZObject, bundle: Bundle<BI>) => Promise<R>;",
  });

  return withFunctionReference;
});

mapTransformers.set("Inject autogenerated header", (nodeMap) => {
  const header = `/**
 * This file was automatically generated by Zapier's Schema to TS tool.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema
 * files, and/or the Schema-to-TS tool and run \`npm run generate\` to
 * regenerate these typings.
 */`;

  const docNode: NamedAst = {
    type: "CUSTOM_TYPE",
    standaloneName: "_",
    params: `insert-snippet|||${header}`,
  };
  return new Map([["_header", docNode], ...Array.from(nodeMap.entries())]);
});

const applyMapTransformer = (
  nodeMap: NodeMap,
  name: string,
  mapTransformer: MapTransformer,
): NodeMap => {
  const result = mapTransformer(nodeMap);
  logger.debug(`Applied transformer: ${name}`);
  return result;
};

export const applyAllTransformations = (nodeMap: NodeMap): NodeMap => {
  logger.debug("Applying %d transformations", mapTransformers.size);
  return Array.from(mapTransformers.entries()).reduce(
    (nm, [name, transformer]) => applyMapTransformer(nm, name, transformer),
    nodeMap,
  );
};
