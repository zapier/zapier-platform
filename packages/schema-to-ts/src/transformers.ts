import { CompilerOptions, NamedAst, NodeMap } from './types.js';
import { insertAtFront, logger } from './utils.js';

/**
 * A transformer that takes a node and can return a new node with
 * changes made.
 */
type NodeTransformer = (node: NamedAst, options: CompilerOptions) => NamedAst;

/**
 * A transformer that takes a whole map of nodes and can return a new
 * map with changes made. Allows for more complex transformations that
 * add or remove top-level schema nodes.
 */
type MapTransformer = (nodeMap: NodeMap, options: CompilerOptions) => NodeMap;

/**
 * Converts a NodeTransformer into a MapTransformer that applies the
 * node transformer to every node in the map.
 */
const makeMapTransformer =
  (transformer: NodeTransformer): MapTransformer =>
  (nodeMap, options) =>
    new Map(
      Array.from(nodeMap.entries()).map(([key, node]) => [
        key,
        transformer(node, options),
      ]),
    );

const mapTransformers: Map<string, MapTransformer> = new Map();

mapTransformers.set(
  'Add links to Schemas on GitHub',
  makeMapTransformer((node) => {
    const comment = node.comment ?? '';
    const url = `https://github.com/zapier/zapier-platform/blob/main/packages/schema/docs/build/schema.md#${node.standaloneName}`;
    return {
      ...node,
      comment: `${comment}\n\n[Docs: ${node.standaloneName}](${url})`,
    };
  }),
);

mapTransformers.set(
  'Inject real function types',
  (nodeMap, options: CompilerOptions) => {
    /**
     * Injects a reference to the PerformFunction type into the
     * FunctionSchema, because in JSON Schema the type is a union of just
     * strings and serialised function payloads.
     */
    const injectFunctionReference = makeMapTransformer((node) => {
      // Search for the "FunctionSchema" JsonSchema, and patch in a
      // references to the (also injected) `PerformFunction` type.
      if (node.standaloneName === 'FunctionSchema' && node.type === 'UNION') {
        const performFuncReference: NamedAst = {
          standaloneName: 'PerformFunction',
          type: 'CUSTOM_TYPE',
          params: `func-ref:perform`,
        };
        return {
          ...node,
          params: [performFuncReference, ...node.params],
        };
      }
      // Leave every other node unchanged.
      return node;
    });
    const withFunctionReference = injectFunctionReference(nodeMap, options);

    // Add the `ZObject` and `Bundle` imports to the top of the file.
    const withFuncAndImport = insertAtFront(
      withFunctionReference,
      'import ZPC object',
      {
        type: 'CUSTOM_TYPE',
        standaloneName: '«Snippet: ZPC import»',
        params: `insert-snippet|||import type { Bundle, ZObject } from "${options.platformCoreCustomImport}";`,
      },
    );

    // Add a type definition for the `PerformFunction`, which is an
    // async function that takes a `ZObject` and a `Bundle` from the
    // custom zapier-platform-core types. Added to the bottom.
    withFuncAndImport.set('PerformFunction', {
      type: 'CUSTOM_TYPE',
      standaloneName: 'PerformFunction',
      comment:
        'A function that performs the action.\n\n@template BI The shape of data in the `bundle.inputData` object.\n@template R The return type of the function.',
      params:
        'insert-snippet|||export type PerformFunction<BI=Record<string, any>, R=any> = (z: ZObject, bundle: Bundle<BI>) => Promise<R>;',
    });

    return withFuncAndImport;
  },
);

mapTransformers.set('Inject autogenerated header', (nodeMap, options) => {
  const header = `/**
 * This file was automatically generated by Zapier's schema-to-ts tool.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema
 * files, and/or the schema-to-ts tool and run its CLI to regenerate
 * these typings.
 * 
 * zapier-platform-schema version: ${options.platformVersion}
 * schema-to-ts compiler version: ${options.compilerVersion}
 */`;

  const docNode: NamedAst = {
    type: 'CUSTOM_TYPE',
    standaloneName: '«Snippet: File Header»',
    params: `insert-snippet|||${header}`,
  };
  return insertAtFront(nodeMap, '_header', docNode);
});

const applyMapTransformer = (
  nodeMap: NodeMap,
  mapTransformer: MapTransformer,
  options: CompilerOptions,
): NodeMap => {
  const result = mapTransformer(nodeMap, options);
  return result;
};

export const applyAllTransformations = (
  nodeMap: NodeMap,
  options: CompilerOptions,
): NodeMap => {
  logger.debug('Applying %d transformations', mapTransformers.size);
  return Array.from(mapTransformers.entries()).reduce(
    (nm, [name, transformer]): NodeMap => {
      if (options.skipPatchFunctions && name === 'Inject real function types') {
        logger.warn(
          { skipPatchFunctions: options.skipPatchFunctions },
          "Skipping transformer '%s' because of --skip-patch-functions ",
          name,
        );
        return nm;
      }

      logger.info(`Applying transformer: ${name}`);
      return applyMapTransformer(nm, transformer, options);
    },
    nodeMap,
  );
};
